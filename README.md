1. Background
  * Justification
  * Goals
2. File Structure
3. Component Class Naming Conventions
4. Identifying Components
5. Formatting

# Boston Interactive Front End Methodology and Standards

## Background

### Justification
There are many (many) documented front methodologies; each with their strengths
and each with their shortcomings. We have found that no one methodology covers
all aspects or all scenarios that we at Boston Interactive need addressed.

This isn't because the existing documents are flawed. It has more to do with
the scope of each document - either covering too much or, in some cases, too
little. Either way, we couldn't find a definitive document that covered all of
our needs. Nor could we find a set of documents that covered our needs without
that set overlapping or contradicting itself.

### Goals
**Efficiency while producing a great deliverable is the ultimate goal.** The
sub-goals that will help us achieve that follow:

* Avoid pixel pushing layout issues
* Leverage frameworks to their fullest extent
* Compartmentalize code by function

#### Definition of good CSS (*Intra*-Team Goals)
* **Predictable**  
  Good CSS should be predictable. When a class is added or removed to an
  element, the developer should be able to accurately predict what effect that
  class's rules will have on the element.

* **Reusable**  
  Developers shouldn't have to write a new rule to, for example, float an
  element to the left. They should be able to reuse a float class, usually
  provided by the framework. Similarly, a developer shouldn't have to repeatedly
  set the background color of elements. There should be a single, reusable
  class for each background color.

* **Maintainable**  
  The addition of new components and features should not require the developer
  to re-factor existing CSS. New components and features should also make use of
  existing CSS to the fullest extent. Often, after careful study, new
  components are found to actually be variations on existing components that
  can be developed using modifier classes exclusively.

* **Scalable**  
  Scalable refers more to the size of the team than the size of the project.
  CSS that is scalable is easily approached by a new developer without a long
  ramp-up period. The CSS should make intuitive sense to the developer after an
  initial inspection.

#### Benefits of good CSS (*Inter*-Team Goals)

* Backend handoff  
  Backend developers are just that: Back End Developers. They shouldn't need to
  massage your CSS to make it work within the Content Management System. Their
  primary concern is the CMS itself. In many circumstances, the back-end
  developer won't have full control of the HTML that is generated by the CMS
  (or modifying the HTML will be prohibitively complicated). Good CSS is more
  easily integrated into a CMS

* Client approval  
  Good CSS is inherently less buggy. This means that producers will encounter
  less surprises during integration and QA.

## Component Class Naming Conventions

### Overview
The majority of CSS classes will be used to define components, define elements
of those components, or to modify those components or their elements. Use
patterns first proposed by BEM to distinguish between these three type of
classes:

1. **Component**  
   Name of the component. If component is more than one word long, use a single
   hyphen to separate the words. For example:

    .tile

2. **Element**  
   Name of the component to which the element belongs, followed by two hyphens,
   followed by the element name. If the element name is more than one word
   long, use a single hyphen to separate the words. For example:

    .tile--body

3. **Modifier**  
   Name of the component that is being modified, followed by two underscores.
   followed by a description of the modifier. If the modifier is more than one
   word long, use a single hyphen to separate the words. You can also modify
   component elements by appending two underscored to the Component/Element
   combo followed by a description of the modifier. For example:

   .tile__orange
   .tile--body__squeezed

### Bootstrap Naming Convention
You'll notice that Bootstrap does *not* follow these naming conventions; which
might seem counterintuitive at first. For example, Bootstrap provides classes
such as `.btn-primary` and .`btn-warning`. According to our method, those
should be named `.btn__primary` and `.btn__warning` respectively. In addition,
Bootstrap's element classes such as `.panel-body` should really be
`.panel--body`.

However, this apparent conflict actually allows us to easily distinguish
between classes provided by the framework and classes that are project
specific. When modifying components or adding elements to components provided
by the framework, the double underscore and double hyphen syntax should still
be used. So the following classes, which expand on Bootstrap components are
valid:

    .panel__hero
    .panel--sub-footer

## Identifying Components
One of the challenges of this approach is identifying what parts of a visual
design constitute a component. Indeed part of the goal of using these naming
conventions is to force the developer to take a step back and break a visual
design into its components.

For some projects, the developer might be lucky enough to be involved in this
process from the content strategy phase. In these cases, components will likely
follow content and content presentation requirements (which are discovered with
the UX team). In most cases, however, it will be up to the developer to
identify the components from an already finished design. Some tips to aid in
this process:

1. **Step away from the designs.**

2. **Involve the design and UI teams.**

3. **Identify which components might lend themselves to components already
   provided by the framework.**

4. **Where appropriate, simplify.**

## Formatting
* One space between the selector and the opening curly brace.
* Property:value pairs are each on their own line with two leading spaces.
* Property:value pairs are alphabetized by property per selector.
* Closing curly brace is on its own line with no spaces.
* Comments follow the doxegen format. Use double slash comments in SASS for
  comments that shouldn't be visible in compiled CSS.

## File Structure

1. Base
2. Layout
3. Component
4. State
5. Theme

6. IE LT 10
7. IE LT 9
8. Hotfix

## Approach

### Leverage HTML elements to their fullest extent
It\'s often useful to start by defining the layout and look of each HTML
element before diving into components. If the designer hasn't provided these
styles, ask for them. Then, make sure that components don't unnecessarily
deviate from those styles.

For example, if `h3` is defined as `font-size: 24px`
and `h4` is defined as `font-size: 20px`, the heading of a `panel` component
should leverage one of those two styles rather than defining its own. (E.g., the
designer shouldn't define panel headings at 22 pixels - which would be between
the h3 and h4 definitions.)

The same applies for layout rules. If an `h1` has 20 pixels of bottom margin,
the designs shouldn't show an element less than 20 pixels below any `h1`
anywhere on the site. If you find cases of this, bring them to the attention of
the designer. Remember that the designer might simply not be aware of the
consistency that is required in good web design - so don't interpret it as
sloppiness or lack of effort.

### Deliverable is set of components, never as templates
This doesn\'t necessarily mean that you won\'t deliver a page of components to
help the back-end dev get started. But you should never approach the project as
a set of templates.

See [Identifying Components](LINK). Once components are identified, it helps to
break them down into elements and then identify how the components and their
elements can be modified. Sometimes, writing these components, their elements,
and how they can be modified out in the hierarchical notation of your choice
helps.

